# —— 解析 marker，得到 template + prompt（JSON优先，文本也兼容）——
- name: Determine template from marker (robust with fallback)
  id: marker
  shell: bash
  run: |
    set -euo pipefail
    MARKER_DIR="app/src/main/assets"
    MARKER="$(ls -1t "$MARKER_DIR"/build_marker_* 2>/dev/null | head -n1 || true)"
    if [ -z "${MARKER:-}" ]; then
      echo "No marker found, fallback to default 'form-template'"
      echo "template=form-template" >> "$GITHUB_OUTPUT"
      echo "prompt=" >> "$GITHUB_OUTPUT"
      exit 0
    fi

    RAW="$(cat "$MARKER")"
    TEMPLATE=""
    PROMPT=""

    # 先尝试按 JSON 解析
    if command -v jq >/dev/null 2>&1 && echo "$RAW" | jq . >/dev/null 2>&1; then
      TEMPLATE="$(echo "$RAW" | jq -r '.template // empty')"
      PROMPT="$(  echo "$RAW" | jq -r '.prompt   // empty')"
    else
      # 纯文本兼容：整文件当模板名用
      TEMPLATE="$(echo "$RAW" | tr -d '\r' | head -n1 | tr -d '"')"
      PROMPT=""
    fi

    case "$TEMPLATE" in
      core-template|form-template|simple-template) ;;
      *) TEMPLATE="form-template" ;;
    esac

    echo "template=$TEMPLATE" >> "$GITHUB_OUTPUT"
    # 长度太短就清空，避免注入无意义文本
    if [ "${#PROMPT}" -lt 10 ]; then PROMPT=""; fi
    # 保护到输出（换行转义）
    printf 'prompt<<__EOF__\n%s\n__EOF__\n' "$PROMPT" >> "$GITHUB_OUTPUT"

    echo "MARKER_USED=$MARKER"
    echo "TEMPLATE=$TEMPLATE"
    echo "PROMPT_LEN=${#PROMPT}"

# —— 应用模板，并把 prompt 注入到 assets —— 
- name: Apply template to app/
  shell: bash
  run: |
    set -euo pipefail
    TPL="${{ steps.marker.outputs.template }}"
    echo "Applying template: $TPL"

    # 1) 复制模板文件到 app/（保留你原来的复制策略）
    rsync -a --delete "templates/$TPL/app/" "app/"

    # 2) 注入 prompt：写到 assets 下，被模板内的 UI 读取
    mkdir -p app/src/main/assets
    PROMPT_FILE="app/src/main/assets/prompt.txt"
    CONTENT_JSON="app/src/main/assets/content.json"

    if [ -n "${{ steps.marker.outputs.prompt }}" ]; then
      # 写入纯文本
      printf '%s\n' "${{ steps.marker.outputs.prompt }}" > "$PROMPT_FILE"
      # 同时写 JSON（看你的模板读取哪个；两个都写最稳妥）
      jq -n --arg p "${{ steps.marker.outputs.prompt }}" '{ prompt:$p }' > "$CONTENT_JSON" || \
        printf '{ "prompt": "%s" }\n' "$(echo "${{ steps.marker.outputs.prompt }}" | sed 's/"/\\"/g')" > "$CONTENT_JSON"
      echo "Prompt injected: $(wc -c < "$PROMPT_FILE") bytes"
    else
      echo "WARN: No prompt to inject, keep template defaults"
    fi

    # 3) 再给一层“非空资产”的快速校验：文件存在且字节数 > 20
    if [ -f "$PROMPT_FILE" ] && [ "$(wc -c < "$PROMPT_FILE")" -gt 20 ]; then
      echo "Prompt asset OK"
    else
      echo "No or too-short prompt; continue with template defaults"
    fi
