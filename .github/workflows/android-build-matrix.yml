name: Android CI (robust + no-empty-apk)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  GRADLE_OPTS: -Dorg.gradle.daemon=false

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      # 1) 拉代码
      - name: Checkout
        uses: actions/checkout@v4

      # 2) JDK 17
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'
          cache: gradle

      # 3) Android SDK（含 sdkmanager/aapt/apkanalyzer 能力）
      - name: Set up Android SDK
        uses: android-actions/setup-android@v3

      # 4) gradlew 可执行
      - name: Make gradlew executable
        run: chmod +x ./gradlew

      # 5) 读取模板（更稳健：先找 marker，找不到用 env.TEMPLATE，最后兜底 form-template）
      - name: Determine template from marker (robust with fallback)
        id: marker
        shell: bash
        run: |
          set -euo pipefail
          marker=$(ls app/src/main/assets/build_marker_*.txt 2>/dev/null | head -n1 || true)
          if [[ -n "$marker" ]]; then
            # 你自己的 marker 第一行写的是 template 名；按需修改解析方式
            template=$(sed -n '1p' "$marker" | tr -d '\r' | xargs)
          elif [[ -n "${TEMPLATE:-}" ]]; then
            template="$TEMPLATE"
          else
            template="form-template"
          fi
          if [[ ! "$template" =~ ^(core-template|form-template|simple-template)$ ]]; then
            echo "::error::Invalid or missing template [$template]. Expected: core-template|form-template|simple-template"
            exit 1
          fi
          echo "template=$template" >> "$GITHUB_OUTPUT"
          echo "Using template: $template"

      # 6) 应用模板到 app/（按你的仓库结构调整模板路径）
      - name: Apply template to app/
        shell: bash
        run: |
          set -euo pipefail
          T="${{ steps.marker.outputs.template }}"
          echo "Apply template $T"
          # 如果你的模板路径不是 templates/$T/app/ ，改这里
          rsync -a --delete "templates/$T/app/" "app/"

      # 7) 快照：让我们一眼看到模板有没有铺进去（排查利器）
      - name: Snapshot app/src/main after templating
        shell: bash
        run: |
          echo "---- tree app/src/main ----"
          ls -R app/src/main || true
          echo "---- AndroidManifest.xml (first 120 lines) ----"
          sed -n '1,120p' app/src/main/AndroidManifest.xml || true

      # 8) 基本必备文件检测（fail-fast）
      - name: Validate module is not empty (fail-fast)
        shell: bash
        run: |
          set -euo pipefail
          test -s app/src/main/AndroidManifest.xml
          test -d app/src/main/java || test -d app/src/main/kotlin
          test -d app/src/main/res
          echo "Module content looks OK."

      # 9) 可选：补 namespace（如果模板没写）
      - name: Patch Gradle namespace (optional)
        shell: bash
        run: |
          set -e
          NS="com.app.generated"
          if ! grep -q "namespace" app/build.gradle*; then
            echo 'android { namespace "'"$NS"'" }' >> app/build.gradle
            echo "Patched namespace to $NS"
          fi

      # 10) 构建 release APK
      - name: Build (unsigned)
        shell: bash
        run: ./gradlew --no-daemon :app:clean :app:assembleRelease

      # 11) 确保有 build-tools/cmdline-tools（用于 aapt/apkanalyzer）
      - name: Ensure build-tools and cmdline-tools
        shell: bash
        run: |
          yes | sdkmanager --licenses >/dev/null
          sdkmanager "build-tools;34.0.0" "cmdline-tools;latest" >/dev/null

      # 12) 找到产物 APK
      - name: Locate release APK
        id: apk
        shell: bash
        run: |
          APK=$(ls app/build/outputs/apk/release/*-release*.apk | head -n1 || true)
          if [[ -z "$APK" ]]; then
            echo "::error::No release APK produced"; exit 1
          fi
          echo "apk=$APK" >> "$GITHUB_OUTPUT"
          echo "Using APK: $APK"

      # 13) 解剖 APK（结构 + Manifest）
      - name: Inspect APK (unzip + aapt + apkanalyzer)
        shell: bash
        run: |
          APK="${{ steps.apk.outputs.apk }}"
          echo "---- zip listing (first 200) ----"
          unzip -l "$APK" | sed -n '1,200p'
          echo "---- aapt dump badging (first 120) ----"
          "$ANDROID_HOME/build-tools/34.0.0/aapt" dump badging "$APK" | sed -n '1,120p' || true
          echo "---- apkanalyzer manifest print ----"
          "$ANDROID_HOME/cmdline-tools/latest/bin/apkanalyzer" manifest print "$APK" || true

      # 14) 防线 1：必须存在 LAUNCHER Activity
      - name: Guard: launcher activity exists
        shell: bash
        run: |
          APK="${{ steps.apk.outputs.apk }}"
          if ! "$ANDROID_HOME/build-tools/34.0.0/aapt" dump badging "$APK" | grep -q "launchable-activity"; then
            echo "::error::No LAUNCHER activity in APK"; exit 1
          fi

      # 15) 防线 2：classes.dex 总体积下限（避免“壳包”）
      - name: Guard: classes.dex minimal size
        env:
          DEX_MIN_BYTES: "80000"     # 你可以根据项目复杂度调大，比如 120000
        shell: bash
        run: |
          APK="${{ steps.apk.outputs.apk }}"
          BYTES=$(unzip -l "$APK" "classes*.dex" | awk 'BEGIN{s=0} $0 ~ /^[ ]*[0-9]+/ {s+=$1} END{print s}')
          echo "classes*.dex total bytes = $BYTES"
          if [[ -z "$BYTES" || "$BYTES" -lt "$DEX_MIN_BYTES" ]]; then
            echo "::error::classes.dex too small ($BYTES bytes)"; exit 1
          fi

      # 16) 防线 3：至少存在一个布局 xml
      - name: Guard: at least one layout XML
        shell: bash
        run: |
          APK="${{ steps.apk.outputs.apk }}"
          RES_COUNT=$(unzip -l "$APK" "res/layout/*.xml" | grep -c "res/layout" || true)
          echo "layout count = $RES_COUNT"
          if [[ "$RES_COUNT" -lt 1 ]]; then
            echo "::error::No layout XML found in APK"; exit 1
          fi

      # 17) 上传产物
      - name: Upload unsigned APK
        uses: actions/upload-artifact@v4
        with:
          name: unsigned-release-apk
          path: ${{ steps.apk.outputs.apk }}
          if-no-files-found: error
