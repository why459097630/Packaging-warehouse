name: Android Build (NDJC)

on:
  workflow_dispatch:
    inputs:
      runId:
        description: "NDJC run id"
        required: false
      template:
        description: "Template key (circle/flow/map/shop/showcase)"
        required: false
      appTitle:
        description: "App title"
        required: false
      packageName:
        description: "Android applicationId"
        required: false
      branch:
        description: "Branch to build (e.g. ndjc-run/<runId>)"
        required: false
      app_dir:
        description: "Android module dir (e.g. templates/circle-basic/app or app)"
        required: false
      preflight_mode:
        description: "Preflight mode: warn (default) or strict"
        required: false
        default: "warn"
      # 🔽 新增：便于手动重放的时候也能传入计划/编排结果
      planB64:
        description: "Base64 of 02_plan.json (Contract v1 plan)"
        required: false
      orchestratorB64:
        description: "Base64 of orchestrator output when no plan"
        required: false
      mode:
        description: "Run mode (A|B)"
        required: false
      contract:
        description: "Contract kind (v1|legacy)"
        required: false
      clientNote:
        description: "Note from API (for debugging)"
        required: false
  repository_dispatch:
    types: [generate-apk]

permissions:
  contents: write

concurrency:
  group: android-build-${{ github.event_name }}-${{ inputs.runId || github.event.client_payload.runId || inputs.branch || github.event.client_payload.ref || github.ref }}
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-22.04
    env:
      KS: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}

    steps:
      - name: Checkout branch (bootstrap)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.branch || github.event.client_payload.ref || github.ref }}

      - name: Resolve inputs → env
        id: resolve
        shell: bash
        run: |
          set -euo pipefail
          RUN_ID="${{ inputs.runId }}"
          if [ -z "${RUN_ID}" ]; then RUN_ID="${{ github.event.client_payload.runId }}"; fi
          if [ -z "${RUN_ID}" ]; then RUN_ID="ndjc-$(date -u +%Y%m%dT%H%M%SZ)"; fi
          echo "RUN_ID=${RUN_ID}" >> "$GITHUB_ENV"

          BR="${{ inputs.branch }}"
          if [ -z "${BR}" ]; then BR="${{ github.event.client_payload.ref }}"; fi
          if [ -z "${BR}" ]; then BR="${{ github.ref }}"; fi
          BR="${BR#refs/heads/}"
          echo "BUILD_BRANCH=${BR}" >> "$GITHUB_ENV"

          echo "runId=${RUN_ID}"   >> "$GITHUB_OUTPUT"
          echo "branch=${BR}"      >> "$GITHUB_OUTPUT"
          echo "Resolved RUN_ID=${RUN_ID}, BUILD_BRANCH=${BR}"

      - name: Guard | require run branch
        if: ${{ steps.resolve.outputs.branch == '' }}
        shell: bash
        run: |
          echo "::error::inputs.branch/client_payload.ref empty. Must provide a run branch like 'ndjc-run/<runId>'."
          exit 1

      - name: Checkout run branch (resolved)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ steps.resolve.outputs.branch }}

      - name: NDJC | Show commit info
        shell: bash
        run: |
          echo "HEAD: $(git rev-parse HEAD)"
          echo "Triggered by: ${{ github.event_name }}"
          echo "inputs.branch: '${{ inputs.branch }}'"
          echo "client_payload.ref: '${{ github.event.client_payload.ref }}'"
          echo "client_payload.sha: '${{ github.event.client_payload.sha }}'"
          git show --name-only --oneline -1

      # ──────────────────────────────────────────────────────────────
      # Materialize inputs BEFORE guards: write requests/<runId>/*
      # ──────────────────────────────────────────────────────────────
      - name: NDJC | Materialize inputs (plan/orchestrator)
        id: materialize
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "requests/${RUN_ID}"

          PLAN_B64='${{ inputs.planB64 || github.event.client_payload.planB64 || '' }}'
          ORCH_B64='${{ inputs.orchestratorB64 || github.event.client_payload.orchestratorB64 || '' }}'
          TEMPLATE='${{ inputs.template || github.event.client_payload.template || '' }}'
          MODE='${{ inputs.mode || github.event.client_payload.mode || 'A' }}'
          APP_TITLE='${{ inputs.appTitle || github.event.client_payload.appTitle || '' }}'
          PKG='${{ inputs.packageName || github.event.client_payload.packageName || '' }}'

          wrote_plan=0
          if [ -n "${PLAN_B64}" ]; then
            echo "Decoding planB64 → requests/${RUN_ID}/02_plan.json"
            echo "${PLAN_B64}" | base64 -d > "requests/${RUN_ID}/02_plan.json"
            wrote_plan=1
          fi

          if [ ${wrote_plan} -eq 0 ] && [ -n "${ORCH_B64}" ]; then
            echo "Decoding orchestratorB64 → requests/${RUN_ID}/01_orchestrator.json"
            echo "${ORCH_B64}" | base64 -d > "requests/${RUN_ID}/01_orchestrator.json"
            echo "Synthesize a minimal 02_plan.json from orchestrator (fallback)"
            node - <<'NODE'
            const fs = require('fs');
            const runId = process.env.RUN_ID;
            const pOrch = `requests/${runId}/01_orchestrator.json`;
            let o = {};
            try { o = JSON.parse(fs.readFileSync(pOrch, 'utf8')); } catch {}
            const meta = {
              template: o.template || process.env.TEMPLATE || 'circle-basic',
              appName: o.appName || process.env.APP_TITLE || 'NDJC App',
              packageId: o.packageId || process.env.PKG || 'com.ndjc.demo.app',
              mode: (o.mode || process.env.MODE || 'A').toUpperCase() === 'B' ? 'B' : 'A',
            };
            const plan = {
              meta: { runId, ...meta },
              text: {
                'NDJC:APP_LABEL': meta.appName,
                'NDJC:HOME_TITLE': o.homeTitle || meta.appName,
                'NDJC:PRIMARY_BUTTON_TEXT': o.mainButtonText || 'Start',
                'NDJC:PACKAGE_NAME': meta.packageId,
              },
              block: {},
              lists: {},
              if: {},
              resources: {},
              hooks: {},
              gradle: { applicationId: meta.packageId }
            };
            fs.writeFileSync(`requests/${runId}/02_plan.json`, JSON.stringify(plan, null, 2));
            NODE
            wrote_plan=1
          fi

          if [ ${wrote_plan} -eq 0 ]; then
            echo "::warning::No planB64/orchestratorB64 provided; creating an empty placeholder plan"
            cat > "requests/${RUN_ID}/02_plan.json" <<PL
            {"meta":{"runId":"${RUN_ID}","template":"${TEMPLATE:-circle-basic}","appName":"${APP_TITLE:-NDJC App}","packageId":"${PKG:-com.ndjc.demo.app}","mode":"${MODE:-A}"},"text":{},"block":{},"lists":{},"if":{},"resources":{},"hooks":{},"gradle":{"applicationId":"${PKG:-com.ndjc.demo.app}"}}
PL
          fi

          # Some guards expect 03_apply_result.json to exist — create a minimal stub if missing
          if [ ! -f "requests/${RUN_ID}/03_apply_result.json" ]; then
            echo '{"ok":true,"note":"placeholder (no apply in CI)","injected":false}' > "requests/${RUN_ID}/03_apply_result.json"
          fi

          # Commit materialized files so they appear in the branch
          git config user.name "ndjc-bot"
          git config user.email "ndjc-bot@users.noreply.github.com"
          git add "requests/${RUN_ID}" || true
          git commit -m "[NDJC ${RUN_ID}] materialize inputs" || true
          git push origin "${BUILD_BRANCH}" || true

      - name: Resolve project paths (APP_DIR/PROJ_DIR)
        id: paths
        shell: bash
        run: |
          set -euo pipefail
          TEMPLATE="${{ inputs.template || github.event.client_payload.template || '' }}"
          APP_DIR_IN="${{ inputs.app_dir || '' }}"
          APP_DIR=""
          if [ -n "$APP_DIR_IN" ]; then
            APP_DIR="$APP_DIR_IN"
          else
            if [ -f app/build.gradle ] || [ -f app/build.gradle.kts ]; then
              APP_DIR="app"
            elif [ -n "$TEMPLATE" ] && [ -d "templates/$TEMPLATE/app" ] && { [ -f "templates/$TEMPLATE/app/build.gradle" ] || [ -f "templates/$TEMPLATE/app/build.gradle.kts" ]; }; then
              APP_DIR="templates/$TEMPLATE/app"
            else
              for d in templates/*/app; do
                if [ -f "$d/build.gradle" ] || [ -f "$d/build.gradle.kts" ]; then APP_DIR="$d"; break; fi
              done
            fi
          fi
          if [ -z "$APP_DIR" ]; then
            echo "::error::Cannot locate Android module. Provide inputs.app_dir or ensure app/build.gradle exists."
            exit 1
          fi
          PROJ_DIR="${APP_DIR%/app}"
          if [ "$PROJ_DIR" = "$APP_DIR" ]; then PROJ_DIR="."; fi
          echo "APP_DIR=$APP_DIR"   >> "$GITHUB_ENV"
          echo "PROJ_DIR=$PROJ_DIR" >> "$GITHUB_ENV"
          echo "app_dir=$APP_DIR"   >> "$GITHUB_OUTPUT"
          echo "proj_dir=$PROJ_DIR" >> "$GITHUB_OUTPUT"
          echo "Resolved APP_DIR=$APP_DIR, PROJ_DIR=$PROJ_DIR"

      - name: Sanity check
        shell: bash
        run: |
          set -euo pipefail
          test -f ./gradlew || { echo "::error::gradlew missing"; exit 1; }
          test -d "$APP_DIR" || { echo "::error::APP_DIR '$APP_DIR' missing"; exit 1; }
          test -f "$APP_DIR/build.gradle" -o -f "$APP_DIR/build.gradle.kts" || { echo "::error::Gradle file missing under $APP_DIR"; exit 1; }
          test -f "$APP_DIR/src/main/AndroidManifest.xml" || { echo "::error::AndroidManifest.xml missing under $APP_DIR/src/main"; exit 1; }

      - name: Ensure Python (alias)
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v python >/dev/null 2>&1; then
            sudo ln -sf /usr/bin/python3 /usr/local/bin/python
          fi
          python --version || true

      - name: NDJC | Guards (strict fail if un-injected)
        shell: bash
        run: |
          set -euo pipefail
          chmod +x scripts/ndjc-guards.sh || true
          scripts/ndjc-guards.sh "$APP_DIR"

      # -------------- 改为 scripts/ndjc-preflight.sh ----------------
      - name: NDJC | Preflight (anchors & resources)
        id: preflight
        shell: bash
        continue-on-error: ${{ (inputs.preflight_mode || 'warn') != 'strict' }}
        run: |
          set -euo pipefail
          mkdir -p anchors build-logs
          if [ -x scripts/ndjc-preflight.sh ]; then
            scripts/ndjc-preflight.sh "$APP_DIR" "${{ inputs.preflight_mode || 'warn' }}" | tee build-logs/preflight.log
          elif [ -x .github/scripts/ndjc-preflight.sh ]; then
            .github/scripts/ndjc-preflight.sh "$APP_DIR" "${{ inputs.preflight_mode || 'warn' }}" | tee build-logs/preflight.log
          else
            echo "::warning::scripts/ndjc-preflight.sh not found; doing minimal checks" | tee build-logs/preflight.log
            [ -f "$APP_DIR/src/main/AndroidManifest.xml" ] || echo "::error::missing $APP_DIR/src/main/AndroidManifest.xml" | tee -a build-logs/preflight.log
            [ -f "$APP_DIR/src/main/res/values/strings.xml" ] || echo "::warning::missing $APP_DIR/src/main/res/values/strings.xml" | tee -a build-logs/preflight.log
          fi

      - name: NDJC | Upload preflight logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: preflight-logs-${{ env.RUN_ID }}
          path: |
            anchors/**
            build-logs/preflight.log
          if-no-files-found: ignore

      - name: NDJC | Env snapshot (pre)
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p build-logs
          {
            echo "=== JAVA ==="; java -version 2>&1 || true
            echo; echo "=== Gradle Wrapper ==="; ./gradlew -v || true
            echo; echo "=== SDK / Build-tools ==="; ls -1 "$ANDROID_SDK_ROOT/build-tools" 2>/dev/null || true
          } | tee build-logs/versions-lock.pre.txt
          ./gradlew -p "$PROJ_DIR" :app:dependencies --configuration releaseRuntimeClasspath --console=plain --no-daemon > build-logs/dependency-tree.pre.txt 2>&1 || true

      - name: NDJC | Upload env snapshot (pre)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: env-pre-${{ env.RUN_ID }}
          path: |
            build-logs/versions-lock.pre.txt
            build-logs/dependency-tree.pre.txt
          if-no-files-found: ignore

      - name: Probe | Manifest
        id: probe_manifest
        shell: bash
        continue-on-error: true
        run: |
          set -euo pipefail
          mkdir -p build-logs
          ./gradlew -p "$PROJ_DIR" :app:processReleaseMainManifest --stacktrace --info --warning-mode all > build-logs/manifest-probe.log 2>&1 || true
          MRF=$(ls -t "$PROJ_DIR/app/build/outputs/logs"/manifest-merger-*.txt 2>/dev/null | head -n1 || true)
          if [ -n "$MRF" ]; then cp "$MRF" build-logs/manifest-merger-report.txt; else echo "manifest-merger report not found" > build-logs/manifest-merger-report.txt; fi

      - name: Probe | Resources
        id: probe_resources
        shell: bash
        continue-on-error: true
        run: |
          set -euo pipefail
          mkdir -p build-logs
          ./gradlew -p "$PROJ_DIR" :app:mergeReleaseResources --stacktrace --info --warning-mode all > build-logs/resource-probe.log 2>&1 || true
          ./gradlew -p "$PROJ_DIR" :app:verifyReleaseResources --stacktrace --info --warning-mode all >> build-logs/resource-probe.log 2>&1 || true
          echo "resource probe done" >> build-logs/resource-probe.log

      - name: Probe | Lint (non-blocking)
        id: probe_lint
        shell: bash
        continue-on-error: true
        run: |
          set -euo pipefail
          mkdir -p build-logs
          ./gradlew -p "$PROJ_DIR" :app:lintRelease --stacktrace --info --warning-mode all > build-logs/lint-probe.log 2>&1 || true
          LHTML=$(ls -t "$PROJ_DIR/app/build/reports/lint-results-release.html" 2>/dev/null | head -n1 || true)
          LXML=$(ls -t "$PROJ_DIR/app/build/reports/lint-results-release.xml" 2>/dev/null | head -n1 || true)
          [ -n "$LHTML" ] && cp "$LHTML" build-logs/lint-report.html || true
          [ -n "$LXML" ] && cp "$LXML" build-logs/lint-report.xml || true

      - name: NDJC | Upload probe logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: probes-${{ env.RUN_ID }}
          path: |
            build-logs/manifest-probe.log
            build-logs/manifest-merger-report.txt
            build-logs/resource-probe.log
            build-logs/lint-probe.log
            build-logs/lint-report.html
            build-logs/lint-report.xml
          if-no-files-found: ignore

      - name: Decode keystore (optional)
        if: ${{ env.KS != '' }}
        shell: bash
        run: |
          echo "${KS}" | base64 -d > "$HOME/release.jks"
          {
            echo "NDJC_KEYSTORE_PATH=$HOME/release.jks"
            echo "NDJC_KEYSTORE_PASSWORD=${{ secrets.ANDROID_KEYSTORE_PASSWORD }}"
            echo "NDJC_KEY_ALIAS=${{ secrets.ANDROID_KEY_ALIAS }}"
            echo "NDJC_KEY_PASSWORD=${{ secrets.ANDROID_KEY_PASSWORD }}"
          } >> "$GITHUB_ENV"
          ls -lh "$HOME/release.jks" || true

      - name: Setup Java 17
        id: jdk
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'
          check-latest: true

      - name: Force JDK 17 for all next steps
        shell: bash
        run: |
          echo "JAVA_HOME=${{ steps.jdk.outputs.path }}" >> "$GITHUB_ENV"
          echo "${{ steps.jdk.outputs.path }}/bin" >> "$GITHUB_PATH"
          echo "ORG_GRADLE_JAVA_HOME=${{ steps.jdk.outputs.path }}" >> "$GITHUB_ENV"
          echo "Using JAVA_HOME=${{ steps.jdk.outputs.path }}"
          java -version

      - name: Setup Gradle cache
        uses: gradle/actions/setup-gradle@v3

      - name: Make gradlew executable
        run: chmod +x ./gradlew

      - name: Build
        id: build
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p build-logs
          echo "JAVA_HOME=$JAVA_HOME"; java -version
          export ORG_GRADLE_JAVA_HOME="$JAVA_HOME"; echo "ORG_GRADLE_JAVA_HOME=$ORG_GRADLE_JAVA_HOME"
          if [ -z "${KS}" ]; then
            echo "No keystore → assembleDebug"
            ./gradlew -p "$PROJ_DIR" :app:clean :app:assembleDebug -x lint --stacktrace --info --warning-mode all 2>&1 | tee build-logs/build.log
            OUTDIR="$PROJ_DIR/app/build/outputs/apk/debug"
            VARIANT=debug
          else
            echo "Keystore present → assembleRelease"
            ./gradlew -p "$PROJ_DIR" :app:clean :app:assembleRelease -x lint --stacktrace --info --warning-mode all 2>&1 | tee build-logs/build.log
            OUTDIR="$PROJ_DIR/app/build/outputs/apk/release"
            VARIANT=release
          fi
          echo "APK_DIR=${OUTDIR:-$PROJ_DIR/app/build/outputs/apk/debug}" >> "$GITHUB_ENV"
          echo "VARIANT=${VARIANT:-debug}" >> "$GITHUB_ENV"

      - name: NDJC | Upload build logs (on failure too)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ env.RUN_ID }}
          path: build-logs/**
          if-no-files-found: ignore

      - name: NDJC | Show build tail (on failure)
        if: failure()
        shell: bash
        run: |
          echo "---- build.log (last 200 lines) ----"
          tail -n 200 build-logs/build.log || true

      - name: NDJC | Env snapshot (post)
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p build-logs
          {
            echo "=== JAVA ==="; java -version 2>&1 || true
            echo; echo "=== Gradle Wrapper ==="; ./gradlew -v || true
            echo; echo "=== SDK / Build-tools ==="; ls -1 "$ANDROID_SDK_ROOT/build-tools" 2>/dev/null || true
          } | tee build-logs/versions-lock.post.txt
          ./gradlew -p "$PROJ_DIR" :app:dependencies --configuration releaseRuntimeClasspath --console=plain --no-daemon > build-logs/dependency-tree.post.txt 2>&1 || true

      - name: NDJC | Upload env snapshot (post)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: env-post-${{ env.RUN_ID }}
          path: |
            build-logs/versions-lock.post.txt
            build-logs/dependency-tree.post.txt
          if-no-files-found: ignore

      - name: Pick APK
        id: pick
        shell: bash
        continue-on-error: true
        run: |
          set -euo pipefail
          SIGNED=$(ls -t "$APK_DIR"/*.apk 2>/dev/null | grep -Ev -- '-unsigned\.apk$' | head -n1 || true)
          UNSIGNED=$(ls -t "$APK_DIR"/*-unsigned.apk 2>/dev/null | head -n1 || true)
          APK=""
          if [ -n "$SIGNED" ]; then
            APK="$SIGNED"; echo "Found signed APK: $APK"
          elif [ -n "$UNSIGNED" ]; then
            APK="$UNSIGNED"; echo "Found unsigned APK: $APK"
          else
            echo "::error::No APK found under $APK_DIR"
          fi
          echo "APK=$APK" >> "$GITHUB_ENV"
          echo "apk=$APK" >> "$GITHUB_OUTPUT"

      - name: Fallback sign release APK (if unsigned but keystore present)
        if: ${{ env.KS != '' && env.VARIANT == 'release' }}
        shell: bash
        continue-on-error: true
        run: |
          if [ -n "${APK:-}" ] && echo "${APK}" | grep -q -- '-unsigned\.apk$'; then
            OUT="${APK%-unsigned.apk}.apk"
            echo "Unsigned APK → signing: ${APK} -> ${OUT}"
            SIG="$ANDROID_SDK_ROOT/build-tools/34.0.0/apksigner"
            if [ ! -x "$SIG" ]; then SIG="$(ls -d $ANDROID_SDK_ROOT/build-tools/* 2>/dev/null | sort -V | tail -n1)/apksigner"; fi
            "$SIG" sign \
              --ks "$NDJC_KEYSTORE_PATH" \
              --ks-pass pass:"$NDJC_KEYSTORE_PASSWORD" \
              --key-pass pass:"$NDJC_KEY_PASSWORD" \
              --ks-key-alias "$NDJC_KEY_ALIAS" \
              --out "$OUT" "$APK"
            ls -lh "$OUT" || true
            echo "APK=$OUT" >> "$GITHUB_ENV"
          else
            echo "No unsigned APK to sign or no APK"
          fi

      - name: Verify Release signature
        if: ${{ env.VARIANT == 'release' && env.APK != '' }}
        shell: bash
        run: |
          SIG="$ANDROID_SDK_ROOT/build-tools/34.0.0/apksigner"
          if [ ! -x "$SIG" ]; then SIG="$(ls -d $ANDROID_SDK_ROOT/build-tools/* 2>/dev/null | sort -V | tail -n1)/apksigner"; fi
          "$SIG" verify --verbose --print-certs "${APK}"

      - name: Upload APK
        if: ${{ env.APK != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: app-${{ env.VARIANT }}-${{ env.RUN_ID }}
          path: ${{ env.APK }}
          if-no-files-found: ignore

      - name: NDJC | Error summary & classification
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "requests/${RUN_ID}"
          SUM_JSON="requests/${RUN_ID}/summary.json"

          classes=""; notes=""
          add_class () { if [ -z "$classes" ]; then classes="$1"; else classes="$classes,$1"; fi; }
          add_note  () { if [ -z "$notes" ];   then notes="$1";   else notes="$notes | $1";   fi; }

          if [ -s anchors/missing_text.txt ] || [ -s anchors/missing_block.txt ]; then add_class "anchor-missing"; add_note "Anchors missing: see anchors/missing_*"; fi
          grep -qi "Manifest merger failed" build-logs/manifest-probe.log build-logs/manifest-merger-report.txt 2>/dev/null && { add_class "manifest"; add_note "Manifest merge failed (see build-logs/manifest-merger-report.txt)"; }
          grep -qiE "Android resource linking failed|resource .* not found|duplicate resources|style .* not found" build-logs/resource-probe.log build-logs/build.log 2>/dev/null && { add_class "resource"; add_note "Resource issues (AAPT2) (see build-logs/resource-probe.log)"; }
          grep -qiE "^e: |This version of the Kotlin compiler is not compatible with the Compose compiler" build-logs/build.log 2>/dev/null && { add_class "kotlin"; add_note "Kotlin/Compose compile error (see build-logs/build.log)"; }
          grep -qiE "Program type already present|Missing class" build-logs/build.log 2>/dev/null && { add_class "proguard"; add_note "R8/Proguard issues (see build-logs/build.log)"; }
          if grep -qi "apksigner" build-logs/build.log 2>/dev/null && [ -z "${APK:-}" ]; then add_class "signing"; add_note "Signing issues (see build-logs/build.log)"; fi
          if [ -f build-logs/dependency-tree.pre.txt ] && [ -f build-logs/dependency-tree.post.txt ]; then
            if ! diff -q build-logs/dependency-tree.pre.txt build-logs/dependency-tree.post.txt >/dev/null 2>&1; then add_class "env-drift"; add_note "Environment/Dependency drift between pre & post snapshots"; fi
          fi

          MT=$( [ -f anchors/missing_text.txt ] && grep -c . anchors/missing_text.txt || echo 0 )
          MB=$( [ -f anchors/missing_block.txt ] && grep -c . anchors/missing_block.txt || echo 0 )

          {
            echo "{"
            echo "  \"runId\": \"${RUN_ID}\"," 
            echo "  \"branch\": \"${BUILD_BRANCH}\"," 
            echo "  \"variant\": \"${VARIANT:-unknown}\"," 
            echo "  \"apk\": \"${APK:-}\"," 
            echo "  \"errors\": { \"classes\": \"${classes:-}\", \"notes\": \"${notes:-}\" },"
            echo "  \"anchors\": { \"missing_text\": ${MT}, \"missing_block\": ${MB} },"
            echo "  \"snapshots\": { \"pre\": \"build-logs/versions-lock.pre.txt\", \"post\": \"build-logs/versions-lock.post.txt\" },"
            echo "  \"generated_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\""
            echo "}"
          } > "$SUM_JSON"

          {
            echo "branch=${BUILD_BRANCH}"
            echo "variant=${VARIANT:-unknown}"
            echo "apk=${APK:-}"
            echo "classes=${classes:-}"
            echo "missing_text=${MT}"
            echo "missing_block=${MB}"
            echo "ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          } > "requests/${RUN_ID}/actions-summary.txt"

          git config user.name "ndjc-bot"
          git config user.email "ndjc-bot@users.noreply.github.com"
          git add "requests/${RUN_ID}" || true
          git commit -m "[NDJC ${RUN_ID}] add error summary & logs" || true
          git push origin "${BUILD_BRANCH}" || true

          {
            echo "### NDJC Build Result"
            echo "- runId: \`${RUN_ID}\`"
            echo "- branch: \`${BUILD_BRANCH}\`"
            echo "- variant: \`${VARIANT:-unknown}\`"
            echo "- apk: \`${APK:-not-found}\`"
            echo "- error classes: \`${classes:-none}\`"
            echo "- anchors missing: text=${MT}, block=${MB}"
            echo ""
            echo "**Reports**"
            echo "- \`build-logs/manifest-merger-report.txt\`"
            echo "- \`build-logs/resource-probe.log\`"
            echo "- \`build-logs/lint-report.(html|xml)\`"
            echo "- \`build-logs/build.log\`"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: NDJC | Upload ALL logs & summary
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ndjc-artifacts-${{ env.RUN_ID }}
          path: |
            anchors/**
            build-logs/**
            requests/${{ env.RUN_ID }}/summary.json
            requests/${{ env.RUN_ID }}/actions-summary.txt
          if-no-files-found: ignore
